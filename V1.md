<h1>ü§î RP - 323 - Programmation fonctionnelle</h1>

>[!TIP]
>**R√©f√©rence Javascript:** <https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference>
>**Tester du code JS** : <https://runjs.app/play>
>**Convertir en PDF** : <https://marketplace.visualstudio.com/items?itemName=manuth.markdown-converter>

<h1>Table des mati√®res</h1>

- [Introduction](#introduction)
- [Op√©rateurs javascript super-cooool üòé](#op√©rateurs-javascript-super-cooool-)
  - [op√©rateur `?:`](#op√©rateur-)
  - [op√©rateur `??`](#op√©rateur--1)
  - [op√©rateur `??=`](#op√©rateur--2)
  - [op√©rateur de d√©composition 'spread' `...`](#op√©rateur-de-d√©composition-spread-)
  - [D√©structuration](#d√©structuration)
- [Date et Heure](#date-et-heure)
  - [Obtenir la date et/ou heure actuelle](#obtenir-la-date-etou-heure-actuelle)
- [Math](#math)
  - [`Math.PI` - la constante œÄ](#mathpi---la-constante-œÄ)
  - [`Math.abs()` - la |valeur absolue| d'un nombre](#mathabs---la-valeur-absolue-dun-nombre)
  - [`Math.pow()` - √©lever √† une puissance](#mathpow---√©lever-√†-une-puissance)
  - [`Math.min()` - plus petite valeur](#mathmin---plus-petite-valeur)
  - [`Math.max()` - plus grande valeur](#mathmax---plus-grande-valeur)
  - [`Math.ceil()` - arrondir √† la prochaine valeur enti√®re la plus proche](#mathceil---arrondir-√†-la-prochaine-valeur-enti√®re-la-plus-proche)
  - [`Math.floor()` - arrondir √† la pr√©c√©dente valeur enti√®re la plus proche](#mathfloor---arrondir-√†-la-pr√©c√©dente-valeur-enti√®re-la-plus-proche)
  - [`Math.round()` - arrondir √† la valeur enti√®re la plus proche](#mathround---arrondir-√†-la-valeur-enti√®re-la-plus-proche)
  - [`Math.trunc()` - supprime la virgule et retourne la partie enti√®re d'un nombre](#mathtrunc---supprime-la-virgule-et-retourne-la-partie-enti√®re-dun-nombre)
  - [`Math.sqrt()` - la ra√ßine carr√©e d'un nombre](#mathsqrt---la-ra√ßine-carr√©e-dun-nombre)
  - [`Math.random()` - g√©n√©rer un nombre al√©atoire entre 0.0 (compris) et 1.0 (non compris)](#mathrandom---g√©n√©rer-un-nombre-al√©atoire-entre-00-compris-et-10-non-compris)
- [JSON](#json)
  - [`JSON.stringify()` - transformer un objet Javascript en JSON](#jsonstringify---transformer-un-objet-javascript-en-json)
  - [`JSON.parse()` - transformer du JSON en objet Javascript](#jsonparse---transformer-du-json-en-objet-javascript)
- [Cha√Ænes de caract√®res](#cha√Ænes-de-caract√®res)
  - [`split()` - un ciseau qui coupe une cha√Æne l√† o√π un caract√®re appara√Æt et produit un tableau](#split---un-ciseau-qui-coupe-une-cha√Æne-l√†-o√π-un-caract√®re-appara√Æt-et-produit-un-tableau)
  - [`trim()`, `trimStart()` et `trimEnd()` - √©puration des espaces en trop dans une cha√Æne (trimming)](#trim-trimstart-et-trimend---√©puration-des-espaces-en-trop-dans-une-cha√Æne-trimming)
  - [`padStart()` et `padEnd()` - aligner le contenu dans une cha√Æne de caract√®res](#padstart-et-padend---aligner-le-contenu-dans-une-cha√Æne-de-caract√®res)
- [Console](#console)
  - [`console.log()` - Afficher un message sur la console](#consolelog---afficher-un-message-sur-la-console)
  - [`console.info()`, `warn()` et `error()` - Afficher un message sur la console (filtrables)](#consoleinfo-warn-et-error---afficher-un-message-sur-la-console-filtrables)
  - [`console.table()` - Afficher tout un tableau ou un objet sur la console](#consoletable---afficher-tout-un-tableau-ou-un-objet-sur-la-console)
  - [`console.time()`, `timeLog()` et `timeEnd()` - Chronom√©trer une dur√©e d'ex√©cution](#consoletime-timelog-et-timeend---chronom√©trer-une-dur√©e-dex√©cution)
- [Tableaux](#tableaux)
  - [`forEach` - parcourir les √©l√©ments d'un tableau](#foreach---parcourir-les-√©l√©ments-dun-tableau)
  - [`entries()` - parcourir les couples index/valeurs d'un tableau](#entries---parcourir-les-couples-indexvaleurs-dun-tableau)
  - [`in` - parcourir les cl√©s d'un tableau](#in---parcourir-les-cl√©s-dun-tableau)
  - [`for...of` - parcourir les valeurs d'un tableau](#forof---parcourir-les-valeurs-dun-tableau)
  - [`find()` - premier √©l√©ment qui satisfait une condition](#find---premier-√©l√©ment-qui-satisfait-une-condition)
  - [`findIndex()` - premier index qui satisfait une condition](#findindex---premier-index-qui-satisfait-une-condition)
  - [`indexOf()` et `lastIndexOf()` - premier/dernier √©l√©ment qui correspond](#indexof-et-lastindexof---premierdernier-√©l√©ment-qui-correspond)
  - [`push()`, `pop()`, `shift()` et `unshift()` - ajouter/supprimer au d√©but/fin d‚Äôun tableau](#push-pop-shift-et-unshift---ajoutersupprimer-au-d√©butfin-dun-tableau)
  - [`slice()` - ne conserver que certaines lignes d'un tableau](#slice---ne-conserver-que-certaines-lignes-dun-tableau)
  - [`splice()` - supprimer/ins√©rer/remplacer des valeurs dans un tableau](#splice---supprimerins√©rerremplacer-des-valeurs-dans-un-tableau)
  - [`concat()` - joindre deux tableaux](#concat---joindre-deux-tableaux)
  - [`join()` - joindre des cha√Ænes de caract√®res](#join---joindre-des-cha√Ænes-de-caract√®res)
  - [`keys()` et `values()` - les cl√©s/valeurs d'un objet](#keys-et-values---les-cl√©svaleurs-dun-objet)
  - [`includes()` - v√©rifier si une valeur est pr√©sente dans un tableau](#includes---v√©rifier-si-une-valeur-est-pr√©sente-dans-un-tableau)
  - [`every()` et `some()` - v√©rifier si plusieurs valeurs sont toutes/quelques pr√©sentes dans un tableau](#every-et-some---v√©rifier-si-plusieurs-valeurs-sont-toutesquelques-pr√©sentes-dans-un-tableau)
  - [`fill()` - remplir un tableau avec des valeurs](#fill---remplir-un-tableau-avec-des-valeurs)
  - [`flat()` - aplatir un tableau](#flat---aplatir-un-tableau)
  - [`sort()` - pour trier un tableau](#sort---pour-trier-un-tableau)
  - [`map()` - tableau avec les r√©sultats d'une fonction](#map---tableau-avec-les-r√©sultats-dune-fonction)
    - [Approfondissement de `map()`](#approfondissement-de-map)
  - [`filter()` - tableau avec les √©l√©ments passant un test](#filter---tableau-avec-les-√©l√©ments-passant-un-test)
    - [Approfondissement de `filter()`](#approfondissement-de-filter)
  - [`groupBy()` - regroupe les √©l√©ments d'un tableau selon une r√®gle](#groupby---regroupe-les-√©l√©ments-dun-tableau-selon-une-r√®gle)
  - [`flatMap()` - cha√Ænage de map() et flat()](#flatmap---cha√Ænage-de-map-et-flat)
  - [`reduce()` et `reduceRight()` - r√©duire un tableau √† une seule valeur](#reduce-et-reduceright---r√©duire-un-tableau-√†-une-seule-valeur)
    - [Approfondissement de `reduce()`](#approfondissement-de-reduce)
    - [Combiner `map()`, `filter()` et `reduce()`](#combiner-map-filter-et-reduce)
    - [Composition de fonctions et pipe](#composition-de-fonctions-et-pipe)
    - [R√©cursion](#r√©cursion)
  - [`reverse()` - inverser l'ordre du tableau](#reverse---inverser-lordre-du-tableau)
- [Techniques](#techniques)
  - [\`\`(backticks) - pour des expressions intelligentes](#backticks---pour-des-expressions-intelligentes)
  - [`new Set()` - pour supprimer les doublons](#new-set---pour-supprimer-les-doublons)
- [Fonctions](#fonctions)
  - [D√©claration de fonction](#d√©claration-de-fonction)
  - [Fonctions imm√©diatement invoqu√©es (IIFE)](#fonctions-imm√©diatement-invoqu√©es-iife)
- [Concepts cl√©s de la programmation fonctionnelle](#concepts-cl√©s-de-la-programmation-fonctionnelle)
- [Conclusion](#conclusion)

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# Introduction

Le but du module 323 est d'apprendre la ¬´‚ÄØProgramation fonctionnelle‚ÄØ(PF) ¬ª, mais aussi devenir capable de **penser d√©claratif** et de construire des solutions **claires, testables et r√©utilisables**.

**√Ä la fin du module, nous saurons‚ÄØ:**
- utiliser efficacement `map()`, `filter()`, `reduce()`, `flatMap()`, `sort()` pour transformer des tableaux **sans effets de bord** ;
- √©crire des **fonctions pures**, travailler avec des **donn√©es immuables** et raisonner avec des **fonctions de premi√®re classe** ;
- **composer** des petites fonctions (patterns *pipe/compose*), pratiquer le **currying** et exploiter les **closures** ;
- appliquer la **r√©cursion** lorsque la structure du probl√®me s‚Äôy pr√™te (arbres, dossiers, parsing, etc.).

# Op√©rateurs javascript super-cooool üòé

## op√©rateur `?:`

> L'expression `question?valeur1:valeur2` retournera `valeur1` si `question` vaut `true` sinon elle retournera `valeur2`.

```javascript
const age = 15;
const resultat = age >= 18 ? 'majeur' : 'mineur'; // 'mineur'
```

## op√©rateur `??`

Cet op√©rateur logique se nomme l'op√©rateur de "coalescence des nuls".

> Renvoie son op√©rande de droite lorsque son op√©rande de gauche vaut `null` ou `undefined` et qui renvoie son op√©rande de gauche sinon.

```javascript
const foo1 = null ?? 'default'; // "default"
const foo2 = 0 ?? 42; // 0
```

>[!CAUTION]
>Contrairement √† l'op√©rateur logique OU (`||`), l'op√©rande de gauche sera √©galement renvoy√© s'il s'agit d'une valeur √©quivalente √† `false` et pas seulement `null` et `undefined`.
>
>‚ö†Ô∏è En d'autres termes **ATTENTION** ‚ÄºÔ∏è lors de l'utilisation de `||` pour fournir une valeur par d√©faut √† une variable, car on peut rencontrer des comportements inattendus lorsqu'on consid√®re certaines valeurs comme correctes et utilisables (par exemple une chaine vide `''` ou `0`) ‚ÄºÔ∏è

```javascript
const foo3 = 0 || 42; // 42 => ATTENTION !
const foo4 = 1 || 42; // 1
const foo5 = null || 'salut !'; // 'salut !'
const foo6 = '' || 'salut !'; // 'salut !' => ATTENTION !
```

## op√©rateur `??=`

Cet op√©rateur logique se nomme l'op√©rateur d'affectation de "coalescence des nuls", √©galement connu sous le nom d'op√©rateur affectation logique nulle.

> √âvalue l'op√©rande de droite et l'attribue √† gauche **UNIQUEMENT si l'op√©rande de gauche est nulle** (`null` ou `undefined`).

```javascript
const a = { duration: 50 };
a.duration ??= 10; // pas fait
a.speed ??= 25; // fait => { duration: 50, speed: 25 }
```

## op√©rateur de d√©composition 'spread' `...`

L'op√©rateur de d√©composition spread `...` permet de d√©composer un it√©rable (comme un tableau) en en ses √©l√©ments distincts. Cela permet de rapidement copier tout ou une partie d'un tableau existant dans un autre tableau ou d'en extraire facilement des parties.

```javascript
// Combiner des valeurs existantes dans un nouveau tableau
const numbersOne = [1, 2, 3];
const numbersTwo = [4, 5, 6];
const numbersCombined = [...numbersOne, ...numbersTwo];

// Extraire uniquement ce qui est utile d'un tableau
const numbers = [1, 2, 3, 4, 5, 6];
const [one, two, ...rest] = numbers;

// Mariage d'objets avec mise √† jour :-)
const myVehicle = {
    brand: 'Ford',
    model: 'Mustang',
    color: 'red',
};
const updateMyVehicle = {
    type: 'car',
    year: 2021,
    color: 'yellow',
};
const myUpdatedVehicle = { ...myVehicle, ...updateMyVehicle };
```

## D√©structuration

L'op√©rateur de d√©composition spread `...` sert aussi √† isoler certains √©l√©ments afin de les utiliser ensuite, et de **mettre le reste** d'un coup ailleurs.

```javascript
const valeurs = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const [a, b, ...c] = valeurs;
console.log(a); // 1
console.log(b); // 2
console.log(c); // [3, 4, 5, 6, 7, 8, 9, 10]
```

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# Date et Heure

Lien vers la documentation officielle : [https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Date](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Date)

## Obtenir la date et/ou heure actuelle

```javascript
const maintenant = new Date(); // Obtenir l'un comme l'autre

console.log(maintenant.toLocaleDateString()); // ex: "06.06.2025"
console.log(maintenant.toLocaleTimeString()); // ex: "15:23:42"

const jour = maintenant.getDate();
const mois = maintenant.getMonth() + 1; // Attention : janvier = 0
const annee = maintenant.getFullYear();
const heure = maintenant.getHours();
const minute = maintenant.getMinutes();
const seconde = maintenant.getSeconds();
console.log(`${jour}/${mois}/${annee} - ${heure}h${minute}`);

// Au format ISO (standard international)
console.log(maintenant.toISOString()); // ex: "2025-06-06T13:23:42.123Z"
```

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# Math

Lien vers la documentation officielle : [https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Math](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Math)

## `Math.PI` - la constante œÄ

Constante qui repr√©sente œÄ (‚âà **3.141592653589793**).
Utile pour **cercles**, **angles** et **trigonom√©trie**.

```javascript
// p√©rim√®tre d‚Äôun cercle (rayon r)
const r = 5;
const perimetre = 2 * Math.PI * r; // ‚âà 31.4159
```

## `Math.abs()` - la \|valeur absolue\| d'un nombre

Renvoie la **valeur absolue** d‚Äôun nombre (toujours ‚â• 0).
Utile pour **distances**, **√©carts**, **valeurs sans signe**. Renvoie `NaN` si l‚Äôargument n‚Äôest pas convertible en nombre.

```javascript
Math.abs(-7);            // 7
Math.abs(0);             // 0
Math.abs(-3.14);         // 3.14

// √âcart (valeur absolue de la diff√©rence)
const a = 10, b = 4;
const ecart = Math.abs(a - b); // 6

// Appliquer sur un tableau
[-3, 0, 2].map(Math.abs); // [3, 0, 2]
```

## `Math.pow()` - √©lever √† une puissance

√âl√®ve une **base** √† une **puissance** : `Math.pow(base, exp)`
√âquivalent moderne : `base ** exp`.

```javascript
Math.pow(2, 3);   // 8
2 ** 3;           // 8 (√©quivalent)

Math.pow(5, 2);   // 25       // carr√©
Math.pow(9, 0.5); // 3        // racine carr√©e
Math.pow(27, 1/3);// 3        // racine cubique
```

## `Math.min()` - plus petite valeur

Retourne la **plus petite** valeur parmi les arguments.
Pour un **tableau**, utilise l‚Äô**op√©rateur spread**.

```javascript
Math.min(3, -1, 7);       // -1

const arr = [4, 1, 9];
Math.min(...arr);         // 1
```

## `Math.max()` - plus grande valeur

Retourne la **plus grande** valeur parmi les arguments.
Pour un **tableau**, utilise l‚Äô**op√©rateur spread**.

```javascript
Math.max(3, -1, 7);      // 7

const arr = [4, 1, 9];
Math.max(...arr);        // 9
```

## `Math.ceil()` - arrondir √† la prochaine valeur enti√®re la plus proche

Renvoie le **plus petit entier ‚â• x** (arrondi vers le haut, vers **+‚àû**).

```javascript
Math.ceil(2.01);   // 3
Math.ceil(3);      // 3
Math.ceil(-1.1);   // -1

// Exemple courant : calcul de pages
const total = 53, parPage = 10;
const pages = Math.ceil(total / parPage); // 6
```

## `Math.floor()` - arrondir √† la pr√©c√©dente valeur enti√®re la plus proche

Renvoie le **plus grand entier ‚â§ x** (arrondi vers le bas, vers **-‚àû**).

```javascript
Math.floor(2.99);  // 2
Math.floor(3);     // 3
Math.floor(-1.1);  // -2

// Ex. discretiser un nombre en index
const x = 4.7;
const index = Math.floor(x); // 4
```

## `Math.round()` - arrondir √† la valeur enti√®re la plus proche

Arrondit au **plus proche entier** ; les valeurs en **.5** vont vers **+‚àû**.

```javascript
Math.round(2.49); // 2
Math.round(2.5);  // 3
Math.round(-1.1); // -1
Math.round(-1.5); // -1
Math.round(-1.6); // -2
```

> Astuce : pour arrondir au demi "**Math.round(x * 2) / 2**".

## `Math.trunc()` - supprime la virgule et retourne la partie enti√®re d'un nombre

Retire la partie **d√©cimale** (tronque), **vers 0**.

```javascript
Math.trunc(3.9);    // 3
Math.trunc(-3.9);   // -3
Math.trunc(3);      // 3
Math.trunc('42.7'); // 42  (conversion implicite)

// Diff√©rence avec floor pour les n√©gatifs
Math.trunc(-1.9);   // -1
Math.floor(-1.9);   // -2
```

## `Math.sqrt()` - la ra√ßine carr√©e d'un nombre

Retourne la **racine carr√©e** de `x` (r√©sultat ‚â• 0).
Si `x < 0` ‚Üí `NaN`. √âquivalent possible : `x ** 0.5`.

```javascript
Math.sqrt(9);     // 3
Math.sqrt(2);     // 1.4142135623...
Math.sqrt(0);     // 0
Math.sqrt(-1);    // NaN

// Distance 2D (th√©or√®me de Pythagore)
const dx = 6, dy = 8;
const dist = Math.sqrt(dx*dx + dy*dy); // 10
```

## `Math.random()` - g√©n√©rer un nombre al√©atoire entre 0.0 (compris) et 1.0 (non compris)

Renvoie un **flottant** `x` tel que `0 ‚â§ x < 1`.
(Pas s√©curis√© pour la crypto ‚Äî pour √ßa, utiliser `crypto.getRandomValues`.)

```javascript
Math.random(); // ex: 0.7321...

// Entier dans [min, max] (inclus)
const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

// Tirer un √©l√©ment au hasard
const item = arr[Math.floor(Math.random() * arr.length)];

// Pile ou face (bool√©en)
const coin = Math.random() < 0.5;
```

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# JSON

Lien vers la documentation officielle : [https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/JSON](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/JSON)

## `JSON.stringify()` - transformer un objet Javascript en JSON

> üîó **Interconnexions**
> - Avant `stringify`, pr√©pare les donn√©es avec `map()`/`filter()` pour **nettoyer** ou **s√©lectionner**.
> - Avec des **dates** ‚Üí pense au *replacer* pour masquer/simplifier.
> - Coupl√© √† des **template literals** (backticks) pour g√©n√©rer des sorties lisibles.

Convertit une **valeur JS** en **cha√Æne JSON**.
Syntaxe : `JSON.stringify(value, replacer?, space?)`

```javascript
// Basique
const obj = { nom: 'Ada', age: 28 };
const json = JSON.stringify(obj);     // '{"nom":"Ada","age":28}'

// Avec indentation (pretty-print)
JSON.stringify(obj, null, 2);
/*
{
  "nom": "Ada",
  "age": 28
}
*/

// Filtrer des cl√©s (replacer = tableau)
JSON.stringify(obj, ['nom']);         // '{"nom":"Ada"}'

// Transformer des valeurs (replacer = fonction)
JSON.stringify({ mdp: 'secret', x: 3.14159 }, (k, v) =>
  k === 'mdp' ? '***' : v
); // '{"mdp":"***","x":3.14159}'
```

> `undefined`, `function` et `Symbol` : **ignor√©s** dans les objets, deviennent `null` dans les tableaux.
> Les `Date` sont s√©rialis√©es au format **ISO** (ex. `"2025-06-06T13:23:42.123Z"`).

## `JSON.parse()` - transformer du JSON en objet Javascript

> üîó **Interconnexions**
> - Apr√®s `parse`, encha√Æne `map()`/`filter()` pour transformer le tableau issu du JSON.
> - Avec un *reviver*, convertis directement les **dates ISO** en `Date`.
> - Valide la structure avec `every()`/`some()` ou `Array.isArray`.

Convertit une **cha√Æne JSON** en **valeur JS**.
Syntaxe : `JSON.parse(text, reviver?)`

```javascript
// Basique
const s = '{"nom":"Ada","age":28,"tags":["js","fp"]}';
const data = JSON.parse(s);
data.nom; // "Ada"
```

```javascript
// Avec "reviver" (ex : convertir les dates ISO en objets Date)
const s = '{"created":"2025-06-06T13:23:42.123Z"}';
const obj = JSON.parse(s, (k, v) =>
  (typeof v === 'string' && /^\d{4}-\d{2}-\d{2}T/.test(v)) ? new Date(v) : v
);
obj.created instanceof Date; // true
```

```javascript
// G√©rer les erreurs de parsing
try {
  JSON.parse('pas du json');
} catch (e) {
  console.error('JSON invalide:', e.message);
}
```

> JSON ‚â† JS : guillemets **doubles**, **pas** de commentaires, ni `undefined/NaN/Infinity`.

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# Cha√Ænes de caract√®res

Lien vers la documentation officielle : [https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/String](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/String)

## `split()` - un ciseau qui coupe une cha√Æne l√† o√π un caract√®re appara√Æt et produit un tableau

> üîó **Interconnexions**
> - `trim()` + `split()` + `filter(Boolean)` pour tokeniser proprement.
        - Ensuite `map(Number)` pour convertir les nombres.
> - Utilise `join()` pour reconstruire une cha√Æne apr√®s transformation.

S√©pare une **cha√Æne** en **tableau** selon un **s√©parateur** (texte ou **RegExp**).
Argument optionnel `limit` = nombre max d‚Äô√©l√©ments.

```javascript
"1,2,3".split(",");            // ["1","2","3"]
"a-b-c-d".split("-", 2);       // ["a","b"]  (limit)
"1,2,3".split(",")[1];         // "2"     (2e √©l√©ment)
"14.03.2008".split(".")[2], 10;    // "2008"  (3e √©l√©ment) + (10 pour forc√© la base d√©cimal)

const txt = "ligne1\nligne2\nligne3";
txt.split("\n");               // ["ligne1","ligne2","ligne3"]

"  a   b   c  ".trim().split(/\s+/); // ["a","b","c"]  (espaces multiples)

"a,,b,".split(",").filter(Boolean);  // ["a","b"]  (sans vides)
"hello".split("");                   // ["h","e","l","l","o"]
```

## `trim()`, `trimStart()` et `trimEnd()` - √©puration des espaces en trop dans une cha√Æne (trimming)

Suppriment les **espaces blancs** (espaces, tabulations, retours ligne) en **bordure** de cha√Æne.

* `trim()` : d√©but **et** fin
* `trimStart()` : d√©but uniquement *(alias historique : `trimLeft()`)*
* `trimEnd()` : fin uniquement *(alias historique : `trimRight()`)*

```javascript
"  hello  ".trim();        // "hello"
"\n\tok \t".trimStart();   // "ok \t"
" done\n".trimEnd();       // " done"

["  a ", " b", "c  "].map(s => s.trim()); // ["a","b","c"]

// Attention : n'enl√®ve rien AU MILIEU
" a  b ".trim();           // "a  b"
```

## `padStart()` et `padEnd()` - aligner le contenu dans une cha√Æne de caract√®res

Compl√®tent une **cha√Æne** jusqu‚Äô√† une **longueur cible** en ajoutant des caract√®res au **d√©but** (`padStart`) ou √† la **fin** (`padEnd`).
Syntaxe : `str.padStart(len, pad?)` / `str.padEnd(len, pad?)`

```javascript
// Z√©ro-padding (num√©ro, date, etc.)
String(7).padStart(3, '0');      // "007"

// Alignement √† droite / gauche
"42".padStart(5);                // "   42"
"42".padEnd(5);                  // "42   "

// Masquer un identifiant
"1234".padStart(16, '‚Ä¢');        // "‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢1234"

// Colonnes fixes
["a", "bb", "ccc"].map(s => s.padEnd(5, ' '));
// ["a    ","bb   ","ccc  "]
```

> Si la cha√Æne est d√©j√† **‚â• longueur cible**, elle est renvoy√©e **inchang√©e**. `pad` par d√©faut = espace.

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# Console

Lien vers la documentation officielle : [https://developer.mozilla.org/fr/docs/Web/API/console](https://developer.mozilla.org/fr/docs/Web/API/console)

## `console.log()` - Afficher un message sur la console

```javascript
console.log('Coucou !'); // Coucou !
```

## `console.info()`, `warn()` et `error()` - Afficher un message sur la console (filtrables)

Affichent des messages avec un **niveau** (info, avertissement, erreur), **filtrables** dans les DevTools.
`warn` met en √©vidence en **jaune**, `error` en **rouge** (avec stack).

```javascript
console.info('D√©marr√© en %d ms', 123);

const quota = 92;
console.warn('Quota √©lev√© : %s%%', quota);

const status = 500, url = '/api/data';
console.error('√âchec requ√™te', { status, url });

// Bon √† savoir : on peut logguer des objets directement
console.info({ user: { id: 1, nom: 'Ada' } });
```

## `console.table()` - Afficher tout un tableau ou un objet sur la console

Affiche des **donn√©es tabulaires** de fa√ßon lisible (tableaux, tableaux d‚Äôobjets, objets).

```javascript
// Tableau d‚Äôobjets
const users = [
  { id: 1, nom: 'Ada', score: 42 },
  { id: 2, nom: 'Linus', score: 37 },
];
console.table(users);

// S√©lection de colonnes
console.table(users, ['id', 'score']);

// Objet d‚Äôobjets
const mesures = {
  a: { x: 1, y: 2 },
  b: { x: 3, y: 4 },
};
console.table(mesures);

// Tableau simple
console.table([10, 20, 30]); // colonnes: (index), value
```

## `console.time()`, `timeLog()` et `timeEnd()` - Chronom√©trer une dur√©e d'ex√©cution

> üîó **Interconnexions**
> - Mesure un pipeline `filter`‚Üí`map`‚Üí`reduce` pour comparer impl√©mentations.
> - Sur de gros tableaux, compare un `sort` + `reduce` vs un `reduce` seul.

Cr√©e un **chronom√®tre** nomm√© :

* `console.time(label)` d√©marre
* `console.timeLog(label, ...data?)` affiche le temps √©coul√© (sans arr√™ter)
* `console.timeEnd(label)` arr√™te et affiche le **total**

```javascript
console.time('build');
// ... code √† mesurer ...
console.timeLog('build', 'apr√®s √©tape 1');
// ... autre travail ...
console.timeEnd('build'); // "build: 123.45 ms"
```

```javascript
// Label facultatif : "default"
console.time();
doSomething();
console.timeEnd(); // "default: 4.12 ms"
```

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# Tableaux

Lien vers la documentation officielle : [https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array](https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Global_Objects/Array)

## `forEach` - parcourir les √©l√©ments d'un tableau

Ex√©cute une **fonction** pour **chaque √©l√©ment** du tableau (dans l‚Äôordre).
Ne retourne rien (**`undefined`**), sert aux **effets de bord**.

```javascript
const arr = ['a', 'b', 'c'];

// (valeur, index, tableau)
arr.forEach((v, i) => {
  console.log(i, v);
});
// 0 'a'
// 1 'b'
// 2 'c'

// Exemple : somme
let somme = 0;
[1, 2, 3].forEach(n => { somme += n; }); // 6
```

## `entries()` - parcourir les couples index/valeurs d'un tableau

Renvoie une **suite de paires** `[index, valeur]` pour chaque √©l√©ment du tableau.
Utile pour **boucler** en ayant la **position** (0, 1, 2, ‚Ä¶) **et** la **valeur**.

```javascript
const arr = ['a', 'b', 'c'];

// Parcours avec position + valeur
for (const [i, v] of arr.entries()) {
  console.log(i, v);
}
// 0 'a'
// 1 'b'
// 2 'c'

// Sans "d√©structuration"
for (const pair of arr.entries()) {
  const i = pair[0];
  const v = pair[1];
  console.log(i, v);
}

// Obtenir un "vrai" tableau de paires
[...arr.entries()]; // [[0,'a'], [1,'b'], [2,'c']]
```

## `in` - parcourir les cl√©s d'un tableau

Parcourt les **cl√©s** d‚Äôun tableau, en tant que **cha√Ænes**.

```javascript
const arr = ['a', 'b', 'c'];
for (const i in arr) {
  console.log(i, arr[i]); // 0 'a' / 1 'b' / 2 'c'
}
```

```javascript
// Trous ignor√©s
const a = [];
a[2] = 'x';
for (const i in a) console.log(i); // "2"
```

```javascript
// Attention : parcourt aussi les propri√©t√©s ajout√©es
arr.extra = 99;
for (const k in arr) console.log(k); // "0","1","2","extra"
```

## `for...of` - parcourir les valeurs d'un tableau

Boucle directement sur les **valeurs** du tableau (dans l‚Äôordre).

```javascript
const arr = ['a', 'b', 'c'];
for (const v of arr) {
  console.log(v); // 'a', 'b', 'c'
}
```

```javascript
// Besoin aussi de l‚Äôindex ? Utilise entries()
for (const [i, v] of arr.entries()) {
  console.log(i, v); // 0 'a' / 1 'b' / 2 'c'
}
```

```javascript
// Fonctionne aussi avec les cha√Ænes, Set, Map (leurs valeurs)
for (const ch of "hey") console.log(ch); // 'h','e','y'
```

## `find()` - premier √©l√©ment qui satisfait une condition

Retourne la **premi√®re valeur** du tableau pour laquelle le **test** renvoie `true`, sinon `undefined`.
Signature : `arr.find((val, i, arr) => test, thisArg?)`

```javascript
[5, 12, 8, 130, 44].find(n => n > 10); // 12
[1, 2, 3].find(n => n > 5);             // undefined

const users = [
  { id: 1, nom: 'Ada' },
  { id: 2, nom: 'Linus' },
];
users.find(u => u.nom === 'Ada');       // { id: 1, nom: 'Ada' }
```

## `findIndex()` - premier index qui satisfait une condition

Retourne l‚Äô**index** du **premier** √©l√©ment pour lequel le test renvoie `true`, sinon **`-1`**.
Signature : `arr.findIndex((val, i, arr) => test, thisArg?)`

```javascript
[5, 12, 8, 130, 44].findIndex(n => n > 10); // 1 (car 12)

// Sur objets
const users = [{id:1},{id:3},{id:5}];
users.findIndex(u => u.id === 3); // 1
users.findIndex(u => u.id === 2); // -1

// Supprimer le premier match
const i = users.findIndex(u => u.id === 3);
if (i !== -1) users.splice(i, 1);
```

## `indexOf()` et `lastIndexOf()` - premier/dernier √©l√©ment qui correspond

Renvoient l‚Äô**index** de la **premi√®re** (`indexOf`) ou **derni√®re** (`lastIndexOf`) occurrence d‚Äôune valeur, sinon **`-1`**.
Signatures :
`arr.indexOf(val, fromIndex = 0)`
`arr.lastIndexOf(val, fromIndex = arr.length - 1)`

```javascript
[1, 2, 3, 2].indexOf(2);          // 1
[1, 2, 3, 2].indexOf(2, 2);       // 3 (√† partir de l‚Äôindex 2)

[1, 2, 3, 2].lastIndexOf(2);      // 3
['a','b','a'].lastIndexOf('a', 1);// 0 (en partant de 1 vers la gauche)

['x','y'].indexOf('z');           // -1
```

```javascript
// Comparaison stricte (===) et r√©f√©rences
const a = { x: 1 };
[a, { x: 1 }].indexOf(a);         // 0
[a, { x: 1 }].indexOf({ x: 1 });  // -1 (objets diff√©rents)

// Cas NaN
[NaN].indexOf(NaN);               // -1
[NaN].includes(NaN);              // true (si besoin)
```

## `push()`, `pop()`, `shift()` et `unshift()` - ajouter/supprimer au d√©but/fin d‚Äôun tableau

**Mutent** le tableau :

* `push(x, ...)` : **ajoute √† la fin**, retourne la **nouvelle longueur**
* `pop()` : **retire la fin**, retourne l‚Äô**√©l√©ment retir√©**
* `unshift(x, ...)` : **ajoute au d√©but**, retourne la **nouvelle longueur**
* `shift()` : **retire le d√©but**, retourne l‚Äô**√©l√©ment retir√©**

```javascript
const arr = [1, 2];

// Fin
arr.push(3);   // 3   (arr ‚Üí [1,2,3])
arr.pop();     // 3   (arr ‚Üí [1,2])

// D√©but
arr.unshift(0); // 3  (arr ‚Üí [0,1,2])
arr.shift();    // 0  (arr ‚Üí [1,2])
```

## `slice()` - ne conserver que certaines lignes d'un tableau

Retourne une **copie** d‚Äôune portion du tableau, **sans le modifier**.
`arr.slice(d√©but, fin?)` ‚Äî `d√©but` inclus, `fin` **exclu**. Indices n√©gatifs = √† partir de la fin.

```javascript
const arr = [0, 1, 2, 3, 4];

arr.slice(1, 4);   // [1, 2, 3]
arr.slice(2);      // [2, 3, 4]
arr.slice(-2);     // [3, 4]

// Cloner un tableau
const copie = arr.slice(); // [0,1,2,3,4]

// Pagination simple
const page = (items, p, n) => items.slice((p-1)*n, p*n);
```

## `splice()` - supprimer/ins√©rer/remplacer des valeurs dans un tableau

**Modifie** le tableau en place.
Signature : `arr.splice(d√©but, deleteCount, ...√©l√©ments√ÄIns√©rer)`
Retourne un **tableau des √©l√©ments supprim√©s**.

```javascript
// Supprimer
const a = [0,1,2,3,4];
const suppr = a.splice(2, 1);   // supprime 1 √©l√©ment √† partir de l‚Äôindex 2
// a ‚Üí [0,1,3,4], suppr ‚Üí [2]

// Ins√©rer (sans supprimer)
const b = [0,1,2,3];
b.splice(2, 0, 'x', 'y');       // ins√®re √† l‚Äôindex 2
// b ‚Üí [0,1,'x','y',2,3]

// Remplacer
const c = [0,1,2,3];
c.splice(1, 2, 'A');            // remplace 1 et 2 par 'A'
// c ‚Üí [0,'A',3]

// Indices n√©gatifs = depuis la fin
const d = [10,20,30,40];
d.splice(-2, 1);                // supprime 30
// d ‚Üí [10,20,40]

// Vider un tableau
const e = [1,2,3];
e.splice(0);                    // e ‚Üí []
```

## `concat()` - joindre deux tableaux

Retourne un **nouveau tableau** en **cha√Ænant** des tableaux et/ou valeurs.
Ne **modifie pas** les originaux (√©quiv. courant : l‚Äôop√©rateur **spread**).

```javascript
const a = [1, 2];
const b = [3, 4];

a.concat(b);            // [1, 2, 3, 4]
a.concat(0, b, 5);      // [1, 2, 0, 3, 4, 5]
[].concat(a, b);        // [1, 2, 3, 4] (clonage simple avec concat)

const nested = [1, [2, 3]];
nested.concat([4, [5]]); // [1, [2,3], 4, [5]]  (pas d‚Äôaplatissement profond)

// Alternative spread
[...a, ...b];           // [1, 2, 3, 4]
```

## `join()` - joindre des cha√Ænes de caract√®res

Rassemble les **√©l√©ments d‚Äôun tableau** en **une seule cha√Æne**.
Syntaxe : `arr.join(s√©parateur?)` ‚Äî s√©parateur par d√©faut **","**.

```javascript
['a','b','c'].join();         // "a,b,c"
['a','b','c'].join(' - ');    // "a - b - c"
[1,2,3].join('');             // "123" (sans s√©parateur)
['usr','local','bin'].join('/'); // "usr/local/bin"

// Valeurs sp√©ciales et "trous"
[null, undefined, ''].join('|'); // "||"
[1, , 3].join('-');              // "1--3"
```

## `keys()` et `values()` - les cl√©s/valeurs d'un objet

`Object.keys(obj)` renvoie un **tableau des cl√©s** propres et √©num√©rables.
`Object.values(obj)` renvoie le **tableau des valeurs** correspondantes. (Pas les propri√©t√©s du **prototype**.)

```javascript
const user = { id: 1, nom: 'Ada', actif: true };

Object.keys(user);   // ["id", "nom", "actif"]
Object.values(user); // [1, "Ada", true]

// Parcourir cl√©s + valeurs
Object.keys(user).forEach(k => {
  console.log(k, user[k]);
});

// Avec un tableau (les indices deviennent des cha√Ænes)
Object.keys(['a','b']);   // ["0","1"]
Object.values(['a','b']); // ["a","b"]
```

> Astuce : pour des **couples [cl√©, valeur]**, utilise aussi `Object.entries(obj)`.

## `includes()` - v√©rifier si une valeur est pr√©sente dans un tableau

Renvoie **true/false** si le tableau **contient** la valeur.
Syntaxe : `arr.includes(val, fromIndex = 0)` (indices n√©gatifs accept√©s).

```javascript
[1, 2, 3].includes(2);        // true
[1, 2, 3].includes(4);        // false
['a','b','c'].includes('a',1);// false (cherche d√®s l‚Äôindex 1)
['a','b','c'].includes('c',-1);// true (depuis la fin)

// Cas sp√©ciaux
[NaN].includes(NaN);          // true
const o = {x:1};
[o].includes(o);              // true
[{x:1}].includes({x:1});      // false (r√©f√©rences diff√©rentes)
```

## `every()` et `some()` - v√©rifier si plusieurs valeurs sont toutes/quelques pr√©sentes dans un tableau

* `every(test)` ‚Üí **true si tous** les √©l√©ments passent le test.
* `some(test)` ‚Üí **true si au moins un** √©l√©ment passe le test.
  S‚Äôarr√™tent **d√®s que le r√©sultat est connu**.

```javascript
const nums = [2, 4, 6];

nums.every(n => n % 2 === 0);  // true  (tous pairs)
nums.some(n => n < 0);         // false (aucun n√©gatif)

// Valider un formulaire : tous non vides ?
['nom','email','pwd'].every(k => form[k]?.trim());

// V√©rifier si une extension est autoris√©e
const allowed = ['jpg','png','gif'];
allowed.some(ext => fileName.endsWith('.' + ext)); // true/false

// Sous-ensemble : arr contient toutes les valeurs de req ?
const req = ['READ','WRITE'];
req.every(r => rights.includes(r)); // true/false
```

## `fill()` - remplir un tableau avec des valeurs

Remplit **en place** un tableau avec une valeur.
`arr.fill(val, d√©but = 0, fin = arr.length)` ‚Äî `d√©but` inclus, `fin` **exclu** (indices n√©gatifs ok).

```javascript
// Basique
Array(5).fill(0);                 // [0,0,0,0,0]

// Plage cibl√©e
const a = [1,2,3,4];
a.fill(9, 1, 3);                  // [1,9,9,4]

// Depuis la fin
[1,2,3,4].fill(7, -2);            // [1,2,7,7]

// Retourne le m√™me tableau (mutation)
const b = [1,2,3];
const r = b.fill(8);              // b === r ‚Üí true
```

## `flat()` - aplatir un tableau

Cr√©e un **nouveau tableau** en aplatissant les **sous-tableaux** jusqu‚Äô√† une **profondeur** donn√©e.
Syntaxe : `arr.flat(depth = 1)`

```javascript
[1, [2, 3], [4]].flat();           // [1, 2, 3, 4]
[1, [2, [3, [4]]]].flat(2);        // [1, 2, 3, [4]]
[1, [2, [3, [4]]]].flat(Infinity); // [1, 2, 3, 4]

// Les "trous" sont supprim√©s
[1, , [2, , 3]].flat();            // [1, 2, 3]
```

## `sort()` - pour trier un tableau

> üîó **Interconnexions**
> - Trie des r√©sultats **apr√®s** `filter()`/`map()` pour √©viter du travail inutile.
> - Pour les **accents**/locales : `localeCompare('fr')`.
> - √âvite de muter : `arr.slice().sort(...)` si tu veux pr√©server l‚Äôoriginal.

**Trie en place** (modifie l‚Äôoriginal).
Par d√©faut : **ordre lexicographique** (comme des cha√Ænes).
Pour un tri **num√©rique** ou **personnalis√©**, fournis une fonction de comparaison.

```javascript
// Par d√©faut (lexicographique)
[3, 20, 100, 4].sort();                // [100, 20, 3, 4]

// Num√©rique (croissant / d√©croissant)
[3, 20, 100, 4].sort((a, b) => a - b); // [3, 4, 20, 100]
[3, 20, 100, 4].sort((a, b) => b - a); // [100, 20, 4, 3]

// Objets : trier par propri√©t√©
const users = [{age: 30},{age: 20},{age: 25}];
users.sort((a, b) => a.age - b.age);   // [{20},{25},{30}]

// Cha√Ænes avec accents (locale)
['√©', 'e', '√®'].sort((a,b) => a.localeCompare(b, 'fr'));
```

## `map()` - tableau avec les r√©sultats d'une fonction

> üîó **Interconnexions**
> - Cha√Æne typique : `arr.filter(...).map(...).reduce(...)`.
> - Pr√©f√®re des **fonctions pures** qui **ne mutent pas** les objets ‚Üí voir *Immuabilit√©* et *Fonctions pures*.
> - Avec `flatMap()` si chaque √©l√©ment peut produire 0..n r√©sultats.

Applique une **fonction** √† chaque √©l√©ment et **retourne un nouveau tableau**.
Ne **modifie pas** l‚Äôoriginal. Longueur **inchang√©e**.
Signature : `arr.map((val, i, arr) => nouveauVal, thisArg?)`

```javascript
// Transformer des nombres
[1, 2, 3].map(n => n * 2);           // [2, 4, 6]

// Extraire une propri√©t√©
const users = [{nom:'Ada'}, {nom:'Linus'}];
users.map(u => u.nom);               // ["Ada", "Linus"]

// Utiliser l‚Äôindex
['a','b','c'].map((v,i) => `${i}:${v}`); // ["0:a","1:b","2:c"]

// Conversion pratique
['1','2','3'].map(Number);           // [1, 2, 3]
```

### Approfondissement de `map()`

La fonction `map()` applique une fonction √† chaque √©l√©ment d'un tableau et renvoie un **nouveau tableau**. Elle ne modifie pas le tableau d'origine et conserve la m√™me longueur. Pour chaque √©l√©ment, `map()` appelle la fonction de rappel avec la valeur, son index et le tableau; la valeur retourn√©e est ins√©r√©e dans le nouveau tableau. Cette op√©ration est pure et pr√©visible¬†: m√™mes entr√©es ‚áí m√™mes sorties.

Par exemple, transformer un tableau de nombres en doublant chaque √©l√©ment¬†:

```javascript
const nombres = [1, 2, 3];
const doubles = nombres.map(n => n * 2); // [2, 4, 6]
```

Veillez √† ne pas utiliser `map()` pour **modifier** directement les √©l√©ments originaux. Les diapositives soulignent qu'une fonction pass√©e √† `map()` doit retourner un nouvel objet plut√¥t que muter l'existant. Si vous devez enrichir des objets, cr√©ez-en une copie¬†:

```javascript
// Mauvaise pratique¬†: la fonction modifie l'objet
eleves.map(e => { e.moyenne = calcMoyenne(e); return e; });
// Bonne pratique¬†: retourner un nouvel objet sans muter l'original
eleves.map(e => ({ ...e, moyenne: calcMoyenne(e) }));
```
## `filter()` - tableau avec les √©l√©ments passant un test

> üîó **Interconnexions**
> - Combine avec `map()` puis `reduce()` pour passer du **bruit** ‚Üí **signal** ‚Üí **agr√©gat**.
> - Pour enlever les doublons avant filtrage : `new Set()` puis `Array.from(...)`.
> - Tester des propri√©t√©s d√©riv√©es ? D‚Äôabord `map()` pour calculer, puis `filter()` sur le r√©sultat.

Garde **uniquement** les √©l√©ments pour lesquels le **test** retourne `true`.
Retourne un **nouveau tableau**, ne **modifie pas** l‚Äôoriginal.
Signature : `arr.filter((val, i, arr) => condition, thisArg?)`

```javascript
// Garder les nombres > 10
[5, 12, 8, 130, 44].filter(n => n > 10); // [12, 130, 44]

// Filtrer des objets (ex : actifs)
const users = [{actif:true},{actif:false},{actif:true}];
users.filter(u => u.actif); // [{actif:true},{actif:true}]

// Retirer les valeurs "falsy" (0, '', null, undefined, NaN)
['a', '', null, 'b'].filter(Boolean); // ["a", "b"]
```

### Approfondissement de `filter()`

La fonction `filter()` s√©lectionne les √©l√©ments d'un tableau qui satisfont un test et renvoie un **nouveau tableau** contenant uniquement ces √©l√©ments. Elle ex√©cute la fonction de test pour chaque √©l√©ment et n'ajoute celui-ci que si le test renvoie `true`. La fonction `filter()` retourne une **copie superficielle** du tableau original, ce qui √©vite de le modifier.

Exemple pour filtrer des salaires sup√©rieurs √† 75¬†000¬†CHF¬†:

```javascript
const salaires = [65000, 80000, 55000, 90000];
const salairesElev√©s = salaires.filter(s => s > 75000); // [80000, 90000]
```

`filter()` est particuli√®rement utile lorsqu'elle est combin√©e avec `map()` et `reduce()` pour former des pipelines de transformation. Veillez √† garder la fonction de test pure et √† √©viter d'alt√©rer les √©l√©ments dans le callback.
## `groupBy()` - regroupe les √©l√©ments d'un tableau selon une r√®gle

Groupe les √©l√©ments **par cl√©** calcul√©e √† partir d‚Äôune fonction.
(En environnements modernes : `array.group(fn)` / `array.groupToMap(fn)`. Sinon, utilise `reduce`.)

```javascript
// Exemple : grouper par ville
const people = [
  { nom: 'Ana',  ville: 'Lyon'  },
  { nom: 'Ben',  ville: 'Lyon'  },
  { nom: 'Eli',  ville: 'Paris' },
];

// Si dispo
people.group(p => p.ville);
// { Lyon: [ {Ana}, {Ben} ], Paris: [ {Eli} ] }

people.groupToMap(p => p.ville);
// Map(2) { 'Lyon' => [ {Ana}, {Ben} ], 'Paris' => [ {Eli} ] }
```

```javascript
// Variante compatible partout (reduce)
const byVille = people.reduce((acc, p) => {
  (acc[p.ville] ??= []).push(p);
  return acc;
}, {});
// { Lyon: [ ... ], Paris: [ ... ] }
```

```javascript
// Autre exemple : pair / impair
[1,2,3,4,5].group?.(n => (n % 2 ? 'impair' : 'pair'))
// { pair: [2,4], impair: [1,3,5] }
```

## `flatMap()` - cha√Ænage de map() et flat()

Fait un **map** puis aplati d‚Äô**un niveau** en **une seule passe**.
Signature : `arr.flatMap((val, i, arr) => valeurOuTableau)`

```javascript
// 1) D√©composer puis aplatir
['a b', 'c d'].flatMap(s => s.split(' '));
// ["a","b","c","d"]

// 2) Transformer en multipliant les √©l√©ments
[1, 2, 3].flatMap(n => [n, n * 2]);
// [1, 2, 2, 4, 3, 6]

// 3) Filtrer en retournant [] pour exclure
[1, 2, 3, 4].flatMap(n => n % 2 ? [n] : []);
// [1, 3]
```

## `reduce()` et `reduceRight()` - r√©duire un tableau √† une seule valeur

> üîó **Interconnexions**
> - Utilise `reduce()` pour impl√©menter `pipe()`/`compose()` (composition de fonctions).
> - `reduceRight()` pour traiter de droite ‚Üí gauche (ex. *compose*).
> - Si `reduce()` devient trop dense, pr√©f√®re des √©tapes `map()`/`filter()` **lisibles**.

Appliquent une **fonction d‚Äôaccumulation** pour produire **une valeur unique**.

* `reduce` : de **gauche ‚Üí droite**
* `reduceRight` : de **droite ‚Üí gauche**
  Signature : `arr.reduce((acc, val, i, arr) => newAcc, init?)`

```javascript
// Somme
[1, 2, 3, 4].reduce((acc, n) => acc + n, 0); // 10

// Max
[5, 1, 9, 3].reduce((m, n) => n > m ? n : m, -Infinity); // 9

// Comptage par valeur (fr√©quences)
['a','b','a','c','b','a'].reduce((map, k) => {
  map[k] = (map[k] || 0) + 1;
  return map;
}, {}); // { a:3, b:2, c:1 }

// reduceRight : sens inverse
['a','b','c'].reduceRight((acc, v) => acc + v, ''); // "cba"
```

### Approfondissement de `reduce()`

`reduce()` applique une fonction d'accumulation sur les √©l√©ments d'un tableau pour produire une **valeur unique**. La fonction d'accumulation re√ßoit l'accumulateur et la valeur courante et doit retourner un nouvel accumulateur. `reduce()` peut parcourir le tableau de gauche √† droite (`reduce()`) ou de droite √† gauche (`reduceRight()`). Ce m√©canisme est utile pour calculer des sommes, des maximums, des statistiques ou regrouper des valeurs.

Par exemple, pour sommer les notes d'une classe¬†:

```javascript
const notes = [5, 6, 4, 5];
const total = notes.reduce((acc, note) => acc + note, 0); // 20
```

`reduce()` est puissant mais peut devenir illisible si l'accumulateur r√©alise des op√©rations complexes ou modifie l'√©tat. Les diapositives conseillent de privil√©gier des fonctions d√©di√©es (`groupBy()`, `filter()`, `map()`) lorsque c'est plus lisible.

### Combiner `map()`, `filter()` et `reduce()`

Ces trois fonctions se combinent pour transformer, filtrer et agr√©ger des donn√©es en un pipeline clair. Par exemple, pour filtrer des produits en stock, appliquer une TVA et calculer le total¬†:

```javascript
const produits = [
  { nom: 'A', prix: 20, enStock: true },
  { nom: 'B', prix: 15, enStock: false },
  { nom: 'C', prix: 30, enStock: true }
];
const tva = 0.077;

const totalTTC = produits
  .filter(p => p.enStock)
  .map(p => p.prix * (1 + tva))
  .reduce((acc, prix) => acc + prix, 0);
```

Ce cha√Ænage est plus lisible que l'utilisation d'une boucle imp√©rative et correspond √† l'esprit d√©claratif de la programmation fonctionnelle.

### Composition de fonctions et pipe

La **composition de fonctions** consiste √† combiner plusieurs fonctions unaires pour obtenir un traitement plus complexe. Les **fonctions unaires** n'ont qu'un seul argument, ce qui simplifie la composition et l'utilisation avec `map()`, `filter()` ou `reduce()`.

Le **currying** transforme une fonction prenant plusieurs arguments en une cha√Æne de fonctions prenant chacune un argument. Cela permet de fixer certains param√®tres et de r√©utiliser la nouvelle fonction¬†:

```javascript
const ajouter = a => b => a + b;
const ajouter10 = ajouter(10);
const resultats = [1, 2, 3].map(ajouter10); // [11, 12, 13]
```

Une **closure** est une fonction qui retient une r√©f√©rence √† son environnement lexical, permettant de cr√©er des fonctions avec m√©moire.

La **fonction pipe** ex√©cute des fonctions en cha√Æne de gauche √† droite. Chaque fonction re√ßoit en entr√©e le r√©sultat de la pr√©c√©dente. On l'impl√©mente g√©n√©ralement avec `reduce()`:

```javascript
const pipe = (...fns) => x => fns.reduce((acc, fn) => fn(acc), x);
```

La **fonction compose** fonctionne comme pipe mais ex√©cute les fonctions de droite √† gauche. Ces deux patterns am√©liorent la lisibilit√© et la testabilit√© du code.

### R√©cursion

La **r√©cursion** d√©signe une fonction qui s'appelle elle‚Äëm√™me jusqu'√† atteindre un cas de base. Elle remplace souvent les boucles dans des langages fonctionnels et est utilis√©e pour parcourir des structures arborescentes ou impl√©menter des algorithmes classiques (factorielles, suites de Fibonacci, recherche dans un arbre). Par exemple, un compte √† rebours r√©cursif¬†:

```javascript
function compteARebours(n) {
  if (n < 0) return;
  console.log(n);
  compteARebours(n - 1);
}
compteARebours(5); // 5 4 3 2 1 0
```

Les langages g√©n√©ralistes comme JavaScript ont des limites de taille de pile. Des appels r√©cursifs trop profonds peuvent provoquer un **stack overflow**. Si le moteur de votre langage ne supporte pas l'optimisation de **r√©cursion terminale**, privil√©giez des approches it√©ratives.
## `reverse()` - inverser l'ordre du tableau

Inverse **en place** l‚Äôordre des √©l√©ments et retourne **le m√™me tableau** (mutation).

```javascript
const a = [1, 2, 3];
a.reverse();        // [3, 2, 1]
a;                  // [3, 2, 1]  (modifi√©)
```

```javascript
// Sans muter l‚Äôoriginal
const b = [1, 2, 3];
const r = b.slice().reverse(); // [3,2,1]
```

```javascript
// Alternative moderne (si dispo) : ne mute pas
[1, 2, 3].toReversed(); // [3,2,1]
```

```javascript
// Inverser une cha√Æne
"salut".split('').reverse().join(''); // "tulas"
```

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# Techniques

## ``(backticks) - pour des expressions intelligentes
> üîó **Interconnexions**
> - Combine avec `JSON.stringify(obj, null, 2)` pour de beaux logs format√©s.
> - Interpole directement des r√©sultats de `map()`/`reduce()` dans une cha√Æne multi‚Äëligne.

Les backticks (template literals) permettent de cr√©er des cha√Ænes de caract√®res **multi‚Äëlignes** et d'y ins√©rer des expressions JavaScript via la syntaxe `${expression}`. Ils sont particuli√®rement utiles pour formater du texte sans concat√©nation et pour interpoler des variables.

```javascript
const nom = 'Ada';
const message = `Bonjour, ${nom}!`;
console.log(message); // Bonjour, Ada!

// Cha√Æne multi‚Äëligne
const texte = `Ligne¬†1
Ligne¬†2`;
```

## `new Set()` - pour supprimer les doublons
> üîó **Interconnexions**
> - `const uniques = [...new Set(arr)]` puis `filter()` pour ne garder que ce qui t‚Äôint√©resse.
> - `Set` + `map()` : cr√©er un index rapide (`Set` des IDs) et filtrer un autre tableau en O(1) par lookup.

Le constructeur `Set` cr√©e un ensemble de valeurs **uniques**. Il est utile pour √©liminer les doublons d'un tableau¬†: convertir le tableau en `Set` supprime automatiquement les valeurs r√©p√©t√©es, puis on peut reconvertir l'ensemble en tableau.

```javascript
const arr = [1, 2, 3, 2, 1];
const uniques = [...new Set(arr)]; // [1, 2, 3]
```

<svg height="12" width="100%" style="padding-top:2em;padding-bottom:1em">
  <rect y="5" width="100%" height="5" fill="#7191B8"/>
</svg>

# Fonctions

## D√©claration de fonction

**Standard**

```javascript
function doStuff(a, b, c) {
    return a + b + c;
}
```

**Sous forme d'expression de fonction**

```javascript
const doStuff = function (a, b, c) {
    return a + b + c;
};
```

**Sous forme d'expression de fonction anonyme**

```javascript
const doStuff = (a, b, c) => {
    return a + b + c;
};
```

**Sous forme raccourcie**

S'il n'y a qu'un seul argument et que son corps n'a qu'une seule expression, on peut omettre le return et le corps de la fonction :

```javascript
const doStuff = (a) => `Salut ${a} !`;
```

## Fonctions imm√©diatement invoqu√©es (IIFE)

IIFE = Immediately Invoked Function Expressions.

Ces fonctions sont d√©finies et **ex√©cut√©es imm√©diatement**. Elles sont souvent utilis√©es pour cr√©er un **contexte isol√©** ou encapsuler du code sans polluer l‚Äôespace global.

```javascript
(function(){ ... })()
```

ou

```javascript
(() => { ... })()
```

# Concepts cl√©s de la programmation fonctionnelle

**Fonctions de premi√®re classe**¬†: en PF, les fonctions sont des valeurs. On peut les stocker dans des variables, les passer en argument et les retourner comme r√©sultats. Les fonctions d'ordre sup√©rieur prennent une fonction en param√®tre ou en retournent une.

**Immuabilit√©**¬†: l'√©tat est consid√©r√© comme immuable. Au lieu de modifier une variable, on cr√©e de nouvelles valeurs. Cette approche √©vite les effets de bord et simplifie les tests, bien qu'elle puisse consommer plus de m√©moire.

**Fonctions pures**¬†: une fonction pure produit toujours la m√™me sortie pour une m√™me entr√©e et ne modifie pas d'√©tat externe. Elles favorisent la composition et la r√©utilisation.

**Paradigmes imp√©ratif vs d√©claratif**¬†: l'approche imp√©rative d√©crit comment faire en d√©taillant les √©tapes, tandis que l'approche d√©clarative d√©crit le r√©sultat souhait√© et laisse l'impl√©mentation g√©rer le comment. La programmation fonctionnelle appartient √† la famille d√©clarative.

# Conclusion

> Votre conclusion avec les √©l√©ments usuels
